// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/05/CPU.hdl

/**
 * The Hack CPU (Central Processing unit), consisting of an ALU,
 * two registers named A and D, and a program counter named PC.
 * The CPU is designed to fetch and execute instructions written in 
 * the Hack machine language. In particular, functions as follows:
 * Executes the inputted instruction according to the Hack machine 
 * language specification. The D and A in the language specification
 * refer to CPU-resident registers, while M refers to the external
 * memory location addressed by A, i.e. to Memory[A]. The inM input 
 * holds the value of this location. If the current instruction needs 
 * to write a value to M, the value is placed in outM, the address 
 * of the target location is placed in the addressM output, and the 
 * writeM control bit is asserted. (When writeM==0, any value may 
 * appear in outM). The outM and writeM outputs are combinational: 
 * they are affected instantaneously by the execution of the current 
 * instruction. The addressM and pc outputs are clocked: although they 
 * are affected by the execution of the current instruction, they commit 
 * to their new values only in the next time step. If reset==1 then the 
 * CPU jumps to address 0 (i.e. pc is set to 0 in next time step) rather 
 * than to the address resulting from executing the current instruction. 
 */

CHIP CPU {

    IN  inM[16],         // M value input  (M = contents of RAM[A])
        instruction[16], // Instruction for execution
        reset;           // Signals whether to re-start the current
                         // program (reset==1) or continue executing
                         // the current program (reset==0).

    OUT outM[16],        // M value output
        writeM,          // Write to M? 
        addressM[15],    // Address in data memory (of M)
        pc[15];          // address of next instruction

    // 15 14 13 12 | 11 10 9  8 | 7  6  5  4 | 3  2  1  0
    // --------------------------------------------------
    // i  x  x  a  | c  c  c  c | c  c  d  d | d  j  j  j

    // C命令 destについて
    // d1 = A
    // d2 = D
    // d3 = M
    PARTS:
    Not(in=instruction[15], out=noti);
    And(a=instruction[15], b=instruction[12], out=AorM);
    And(a=instruction[15], b=instruction[3], out=writeM);
    And(a=instruction[15], b=instruction[4], out=loadD);

    // ARegister
    Mux16(a=aluOut, b=instruction, sel=noti, out=AorC);

    Or(a=noti, b=instruction[5], out=loadA);
    ARegister(in=AorC, load=loadA, out=outA, out[0..14]=addressM);

    Mux16(a=outA, b=inM, sel=AorM, out=outAorM);

    ALU(x=outD, y=outAorM,
        zx=instruction[11],
        nx=instruction[10],
        zy=instruction[9],
        ny=instruction[8],
        f=instruction[7],
        no=instruction[6],
        out=outM, out=aluOut,
        zr=zr,  // out = 0
        ng=ng   // out > 0
    );

    // DRegister
    DRegister(in=aluOut, load=loadD, out=outD);

    // instrucion[2] = 0
    // And(a=zr, b=instruction[2], out=ozr);


    // DMux8Way(in=true, sel[0]=j1, sel[1]=j2, sel[2]=j3,a=null,b=jgt,c=jeq,d=jge,e=jlt,f=jne,g=jle,h=jmp);



    // JMP
    // DMux8Way(in=true, sel[0]=j1, sel[1]=j2, sel[2]=j3,a=null,b=jgt,c=jeq,d=jge,e=jlt,f=jne,g=jle,h=jmp);
    // DMux8Way(in=true, sel[0]=instruction[2],sel[1]=instruction[1], sel[2]=instruction[0],a=inull,b=ijgt,c=ijeq,d=ijge,e=ijlt,f=ijne,g=ijle,h=ijmp);
    // And(a=null, b=inull, out=onull);
    // And(a=jgt, b=ijgt, out=ojgt);
    // And(a=jeq, b=ijeq, out=ojeq);
    // And(a=jge, b=ijge, out=ojge);
    // And(a=jlt, b=ijlt, out=ojlt);
    // And(a=jne, b=ijne, out=ojne);
    // And(a=jle, b=ijle, out=ojle);
    // And(a=jmp, b=ijmp, out=ojmp);

    // Or8Way(
    //     in[0]=onull,
    //     in[1]=ojgt,
    //     in[2]=ojeq,
    //     in[3]=ojge,
    //     in[4]=ojlt,
    //     in[5]=ojne,
    //     in[6]=ojle,
    //     in[7]=ojmp,
    //     out=ojr);

    // And(a=j1, b=instruction[2], out=outj1);
    // And(a=j2, b=instruction[1], out=outj2);

    // Not(in=j1, out=j3); // 1 jgt, jge, jlt, jle
    //                     // 0 null, jeq, jne, jmp
    // And(a=j3, b=instrucion[0], out=outj3);

    // And(a=outj2, b=outj3, out=bjmp); // ((j1 == j3) && j2)

    And(a=ng, b=instrucion[2], out=w1);
    And(a=zr, b=instrucion[1], out=w2);

    Or(a=zr, b=ng, out=minus);
    Not(in=minus, out=plus);
    And(a=plus, b=instrucion[0], out=w3);

    Or(a=w1, b=w2, out=or12);
    Or(a=or12, b=w3, out=or123);
    And(a=or123, b=instrucion[15], out=inc);
    Not(in=inc, out=isJMP);

    PC(in=outA, inc=inc, load=isJMP, reset=reset, out[0..14]=pc);

    // // 次のアドレス
    // PC(in=outA, load=reset, inc=, reset=reset, out=pc);

    // let regA = ARegister.in(inM)
    // let regD = DRegister.in(regD)

    // const inAlu = (!!instruction[15]) ? inM : regD

    // ALU(x=inAlu, y=regA, zx=instruction[11], nx=instruction[10], zy=instruction[9], ny=instruction[8], f=instruction[7], no=instruction[6], out=regD, out=outM zr=j2, ng=j1);


    // PC(in=regA, load=reset, )
}